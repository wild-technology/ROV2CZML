// Set your Ion default token (for both Bathymetry and loading the CZML)
Cesium.Ion.defaultAccessToken =
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9."
+ "eyJqdGkiOiIyMjA1Y2ZhZC1hM2IwLTQ4MzQtYWYwZi00MTFmZTEwYjJjMDMiLCJpZCI6MTQ4NTYyLCJpYXQiOjE3MzU4ODQ1Nzh9."
+ "jqwp1s3lkvA4Us0vA0skO03kqVya7Sj22kJJKWV6D8M";

// We'll create a hidden canvas for the color ramp
const rampCanvas = document.createElement("canvas");
rampCanvas.id = "colorRamp";
rampCanvas.style.display = "none";
document.body.appendChild(rampCanvas);

// We'll create a 'toolbar' div for the UI controls
const toolbarDiv = document.createElement("div");
toolbarDiv.id = "toolbar";
document.body.appendChild(toolbarDiv);

/*=====================================================================================
  1) Create the viewer with Cesium World Bathymetry, advanced lighting, fog toggles, etc.
=====================================================================================*/
(async function () {
  // Because we need to await the bathymetry, do it first:
  const bathymetry = await Cesium.createWorldBathymetryAsync({
    requestVertexNormals: true,
  });

  // Now create the viewer using that as terrain
  const viewer = new Cesium.Viewer("cesiumContainer", {
    timeline: false,
    animation: false,
    terrainProvider: bathymetry,
  });

  // Switch the base layer to the CesiumJS "Natural Earth II" or whichever
  // layer is at index 11. Adjust if your environment differs.
  viewer.baseLayerPicker.viewModel.selectedImagery =
    viewer.baseLayerPicker.viewModel.imageryProviderViewModels[11];

  const scene = viewer.scene;
  // Prevent the user from tilting beyond the ellipsoid surface
  scene.screenSpaceCameraController.maximumTiltAngle = Math.PI / 2.0;

  // Some additional globe settings
  const globe = scene.globe;
  globe.enableLighting = true;
  globe.maximumScreenSpaceError = 1.0; // load higher resolution for better seafloor shading

  // Add a toggle to turn lighting on/off
  Sandcastle.addToggleButton("Lighting enabled", true, function (checked) {
    globe.enableLighting = checked;
  });

  // Light the scene with a hillshade-like effect
  scene.light = new Cesium.DirectionalLight({
    direction: new Cesium.Cartesian3(1, 0, 0), // We update this every frame below
  });

  const camera = scene.camera;
  const cameraMaxHeight = globe.ellipsoid.maximumRadius * 2;
  const scratchNormal = new Cesium.Cartesian3();

  /*========================================================
    2) Pre-render hook to update the directional light
       based on the camera location.
  ========================================================*/
  scene.preRender.addEventListener(function (scene, time) {
    const surfaceNormal = globe.ellipsoid.geodeticSurfaceNormal(
      camera.positionWC,
      scratchNormal
    );
    Cesium.Cartesian3.negate(surfaceNormal, surfaceNormal);
    Cesium.Cartesian3.add(surfaceNormal, camera.rightWC, surfaceNormal);
    Cesium.Cartesian3.normalize(surfaceNormal, scene.light.direction);

    const zoomMagnitude =
      Cesium.Cartesian3.magnitude(camera.positionWC) / cameraMaxHeight;
    updateGlobeMaterialUniforms(zoomMagnitude);
  });

  // Fog toggle
  Sandcastle.addToggleButton("Fog enabled", true, (checked) => {
    scene.fog.enabled = checked;
    globe.showGroundAtmosphere = checked;
  });

  // Setup advanced color shading / contour lines
  let showContourLines = true;
  let showElevationColorRamp = true;
  let invertContourLines = false;

  const minHeight = -10000.0;
  const seaLevel = 0.0;
  const maxHeight = 2000.0;

  // We'll create a color ramp on the hidden canvas
  function getColorRamp() {
    const ramp = document.getElementById("colorRamp");
    ramp.width = 100;
    ramp.height = 15;
    const ctx = ramp.getContext("2d");
    const grd = ctx.createLinearGradient(0, 0, 100, 0);

    // We'll define a small helper to scale the gradient stops
    const range = maxHeight - minHeight;
    function d(h) {
      return (h - minHeight) / range;
    }

    // Add color stops from shallow water => deep => land
    grd.addColorStop(d(maxHeight), "#B79E6C");
    grd.addColorStop(d(100.0), "#FBFFEE");
    grd.addColorStop(d(0.0), "#F9FCCA");
    grd.addColorStop(d(-500.0), "#BDE7AD");
    grd.addColorStop(d(-1000.0), "#81D2A3");
    grd.addColorStop(d(-1500.0), "#5AB7A4");
    grd.addColorStop(d(-2000.0), "#4C9AA0");
    grd.addColorStop(d(-2500.0), "#437D9A");
    grd.addColorStop(d(-4000.0), "#3E6194");
    grd.addColorStop(d(-5000.0), "#424380");
    grd.addColorStop(d(-8000.0), "#392D52");
    grd.addColorStop(d(minHeight), "#291C2F");

    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, ramp.width, ramp.height);

    return ramp;
  }

  // Optionally define a composite material that merges color ramp with contour lines
  function getElevationContourMaterial() {
    return new Cesium.Material({
      fabric: {
        type: "ElevationColorContour",
        materials: {
          contourMaterial: { type: "ElevationContour" },
          elevationRampMaterial: { type: "ElevationRamp" },
        },
        components: {
          diffuse:
            "(1.0 - contourMaterial.alpha) * elevationRampMaterial.diffuse + contourMaterial.alpha * contourMaterial.diffuse",
          alpha: "max(contourMaterial.alpha, elevationRampMaterial.alpha)",
        },
      },
      translucent: false,
    });
  }

  function updateGlobeMaterialUniforms(zoomMagnitude) {
    const material = globe.material;
    if (!Cesium.defined(material)) {
      return;
    }
    // Adjust contour spacing based on zoom
    const spacing = 5.0 * Math.pow(10, Math.floor(4 * zoomMagnitude));
    if (showContourLines) {
      const uniforms = showElevationColorRamp
        ? material.materials.contourMaterial.uniforms
        : material.uniforms;
      uniforms.spacing = spacing * scene.verticalExaggeration;
    }
    if (showElevationColorRamp) {
      const uniforms = showContourLines
        ? material.materials.elevationRampMaterial.uniforms
        : material.uniforms;
      uniforms.spacing = spacing * scene.verticalExaggeration;
      uniforms.minimumHeight = minHeight * scene.verticalExaggeration;
      uniforms.maximumHeight = maxHeight * scene.verticalExaggeration;
    }
  }

  function updateGlobeMaterial() {
    let material;
    if (showContourLines) {
      if (showElevationColorRamp) {
        material = getElevationContourMaterial();
        let shadingUniforms = material.materials.elevationRampMaterial.uniforms;
        shadingUniforms.image = getColorRamp();
        shadingUniforms.minimumHeight = minHeight * scene.verticalExaggeration;
        shadingUniforms.maximumHeight = maxHeight * scene.verticalExaggeration;

        shadingUniforms = material.materials.contourMaterial.uniforms;
        shadingUniforms.width = 1.0;
        shadingUniforms.spacing =
          500.0 * scene.verticalExaggeration; // default contour spacing
        shadingUniforms.color = invertContourLines
          ? Cesium.Color.WHITE.withAlpha(0.5)
          : Cesium.Color.BLACK.withAlpha(0.5);

        globe.material = material;
        return;
      }

      material = Cesium.Material.fromType("ElevationContour");
      const shadingUniforms = material.uniforms;
      shadingUniforms.width = 1.0;
      shadingUniforms.spacing = 500.0 * scene.verticalExaggeration;
      shadingUniforms.color = invertContourLines
        ? Cesium.Color.WHITE
        : Cesium.Color.BLACK;
      globe.material = material;
      return;
    }

    if (showElevationColorRamp) {
      material = Cesium.Material.fromType("ElevationRamp");
      const shadingUniforms = material.uniforms;
      shadingUniforms.image = getColorRamp();
      shadingUniforms.minimumHeight = minHeight * scene.verticalExaggeration;
      shadingUniforms.maximumHeight = maxHeight * scene.verticalExaggeration;
      globe.material = material;
      return;
    }

    globe.material = undefined; // No special material
  }

  updateGlobeMaterial();

  Sandcastle.addToggleButton(
    "Color ramp enabled",
    showElevationColorRamp,
    function (checked) {
      showElevationColorRamp = checked;
      updateGlobeMaterial();
    }
  );

  Sandcastle.addToggleButton(
    "Contour lines enabled",
    showContourLines,
    function (checked) {
      showContourLines = checked;
      updateGlobeMaterial();
    }
  );

  Sandcastle.addToggleButton(
    "Invert contour line color",
    invertContourLines,
    function (checked) {
      invertContourLines = checked;
      updateGlobeMaterial();
    }
  );

  // Vertical exaggeration
  const viewModel = {
    exaggeration: scene.verticalExaggeration,
  };

  function updateExaggeration() {
    scene.verticalExaggeration = Number(viewModel.exaggeration);
  }

  Cesium.knockout.track(viewModel);
  Cesium.knockout.applyBindings(viewModel, toolbarDiv);
  for (const name in viewModel) {
    if (Object.prototype.hasOwnProperty.call(viewModel, name)) {
      Cesium.knockout.getObservable(viewModel, name).subscribe(updateExaggeration);
    }
  }

  // Optionally set an initial camera
  scene.camera.setView({
    destination: new Cesium.Cartesian3(
      -3877002.181627189,
      5147948.256341475,
      864384.3423478723
    ),
    orientation: new Cesium.HeadingPitchRoll(
      5.914830423853524,
      -0.7139104486007932,
      0.00017507632714419685
    ),
  });

  /*======================================================================
    3) Load your CZML from Ion (Asset ID = 3167038), track "Hercules"
  ======================================================================*/
  try {
    const czmlResource = Cesium.IonResource.fromAssetId(3167038);
    const czmlDataSource = await Cesium.CzmlDataSource.load(czmlResource);
    viewer.dataSources.add(czmlDataSource);

    // If the czml has an entity "Hercules", track it
    const herculesEntity = czmlDataSource.entities.getById("Hercules");
    if (herculesEntity) {
      viewer.trackedEntity = herculesEntity;
    }

    viewer.zoomTo(czmlDataSource);
  } catch (err) {
    console.error("Error loading the CZML from Ion:", err);
  }
})();
