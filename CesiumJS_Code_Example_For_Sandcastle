// Set the access token
Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJhYTJkYjIyOS1hNWFlLTRmMTAtOTU1YS1hM2YzODVlNjljMjQiLCJpZCI6MTQ4NTYyLCJpYXQiOjE3NDExMDkxMTZ9.D2HdhLSFyS5ZpnQPjSbQaawpXkNfCKzDUpks74xO-30";

(async function () {
  // Create a color ramp element for the bathymetry visualization
  const colorRampElement = document.createElement('canvas');
  colorRampElement.id = "colorRamp";
  colorRampElement.width = 100;
  colorRampElement.height = 15;
  document.body.appendChild(colorRampElement);

  // Create the viewer with bathymetry
  const viewer = new Cesium.Viewer("cesiumContainer", {
    timeline: true,
    animation: true,
    terrainProvider: await Cesium.createWorldBathymetryAsync({
      requestVertexNormals: true,
    }),
  });

  // Set to a good base layer for underwater visualization
  viewer.baseLayerPicker.viewModel.selectedImagery =
    viewer.baseLayerPicker.viewModel.imageryProviderViewModels[11];

  const scene = viewer.scene;
  const globe = scene.globe;

  // Enable lighting and high resolution terrain
  globe.enableLighting = true;
  globe.maximumScreenSpaceError = 1.0;
  globe.depthTestAgainstTerrain = false; // Let the ROV be visible through terrain

  // Prevent the user from tilting beyond the ellipsoid surface
  scene.screenSpaceCameraController.maximumTiltAngle = Math.PI / 2.0;

  // Light the scene with a hillshade effect
  scene.light = new Cesium.DirectionalLight({
    direction: new Cesium.Cartesian3(1, 0, 0), // Updated dynamically
  });

  const camera = scene.camera;
  const cameraMaxHeight = globe.ellipsoid.maximumRadius * 2;
  const scratchNormal = new Cesium.Cartesian3();

  // Update light direction based on camera position
  scene.preRender.addEventListener(function (scene, time) {
    const surfaceNormal = globe.ellipsoid.geodeticSurfaceNormal(
      camera.positionWC,
      scratchNormal,
    );
    const negativeNormal = Cesium.Cartesian3.negate(surfaceNormal, surfaceNormal);
    scene.light.direction = Cesium.Cartesian3.normalize(
      Cesium.Cartesian3.add(negativeNormal, camera.rightWC, surfaceNormal),
      scene.light.direction,
    );

    const zoomMagnitude =
      Cesium.Cartesian3.magnitude(camera.positionWC) / cameraMaxHeight;

    updateGlobeMaterialUniforms(zoomMagnitude);
  });

  // ===== Globe material setup (color ramp and contour lines) =====
  const minHeight = -10000.0;
  const seaLevel = 0.0;
  const maxHeight = 2000.0;
  const countourLineSpacing = 500.0;
  let showContourLines = true;
  let showElevationColorRamp = true;
  let invertContourLines = false;

  const range = maxHeight - minHeight;
  const d = (height) => (height - minHeight) / range;

  // Create a color ramp for ocean depths
  function getColorRamp() {
    const ramp = document.getElementById("colorRamp");
    ramp.width = 100;
    ramp.height = 15;
    const ctx = ramp.getContext("2d");
    const grd = ctx.createLinearGradient(0, 0, 100, 0);

    // Deep ocean color scale (cmocean 'deep')
    grd.addColorStop(d(maxHeight), "#B79E6C");
    grd.addColorStop(d(100.0), "#FBFFEE");
    grd.addColorStop(d(0.0), "#F9FCCA");
    grd.addColorStop(d(-500.0), "#BDE7AD");
    grd.addColorStop(d(-1000.0), "#81D2A3");
    grd.addColorStop(d(-1500.0), "#5AB7A4");
    grd.addColorStop(d(-2000.0), "#4C9AA0");
    grd.addColorStop(d(-2500.0), "#437D9A");
    grd.addColorStop(d(-4000.0), "#3E6194");
    grd.addColorStop(d(-5000.0), "#424380");
    grd.addColorStop(d(-8000.0), "#392D52");
    grd.addColorStop(d(minHeight), "#291C2F");

    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, ramp.width, ramp.height);

    return ramp;
  }

  function getElevationContourMaterial() {
    // Creates a composite material with both elevation shading and contour lines
    return new Cesium.Material({
      fabric: {
        type: "ElevationColorContour",
        materials: {
          contourMaterial: {
            type: "ElevationContour",
          },
          elevationRampMaterial: {
            type: "ElevationRamp",
          },
        },
        components: {
          diffuse:
            "(1.0 - contourMaterial.alpha) * elevationRampMaterial.diffuse + contourMaterial.alpha * contourMaterial.diffuse",
          alpha: "max(contourMaterial.alpha, elevationRampMaterial.alpha)",
        },
      },
      translucent: false,
    });
  }

  function updateGlobeMaterialUniforms(zoomMagnitude) {
    const material = globe.material;
    if (!Cesium.defined(material)) {
      return;
    }

    const spacing = 5.0 * Math.pow(10, Math.floor(4 * zoomMagnitude));
    if (showContourLines) {
      const uniforms = showElevationColorRamp
        ? material.materials.contourMaterial.uniforms
        : material.uniforms;

      uniforms.spacing = spacing * scene.verticalExaggeration;
    }

    if (showElevationColorRamp) {
      const uniforms = showContourLines
        ? material.materials.elevationRampMaterial.uniforms
        : material.uniforms;
      uniforms.spacing = spacing * scene.verticalExaggeration;
      uniforms.minimumHeight = minHeight * scene.verticalExaggeration;
      uniforms.maximumHeight = maxHeight * scene.verticalExaggeration;
    }
  }

  function updateGlobeMaterial() {
    let material;
    if (showContourLines) {
      if (showElevationColorRamp) {
        material = getElevationContourMaterial();
        let shadingUniforms = material.materials.elevationRampMaterial.uniforms;
        shadingUniforms.image = getColorRamp();
        shadingUniforms.minimumHeight = minHeight * scene.verticalExaggeration;
        shadingUniforms.maximumHeight = maxHeight * scene.verticalExaggeration;
        shadingUniforms = material.materials.contourMaterial.uniforms;
        shadingUniforms.width = 1.0;
        shadingUniforms.spacing = countourLineSpacing * scene.verticalExaggeration;
        shadingUniforms.color = invertContourLines
          ? Cesium.Color.WHITE.withAlpha(0.5)
          : Cesium.Color.BLACK.withAlpha(0.5);
        globe.material = material;
        return;
      }

      material = Cesium.Material.fromType("ElevationContour");
      const shadingUniforms = material.uniforms;
      shadingUniforms.width = 1.0;
      shadingUniforms.spacing = countourLineSpacing * scene.verticalExaggeration;
      shadingUniforms.color = invertContourLines
        ? Cesium.Color.WHITE
        : Cesium.Color.BLACK;
      globe.material = material;
      return;
    }

    if (showElevationColorRamp) {
      material = Cesium.Material.fromType("ElevationRamp");
      const shadingUniforms = material.uniforms;
      shadingUniforms.image = getColorRamp();
      shadingUniforms.minimumHeight = minHeight * scene.verticalExaggeration;
      shadingUniforms.maximumHeight = maxHeight * scene.verticalExaggeration;
      globe.material = material;
      return;
    }

    globe.material = undefined;
  }

  // Set up vertical exaggeration controls
  const viewModel = {
    exaggeration: 1.0,
    minHeight: minHeight,
    maxHeight: maxHeight,
  };

  function updateExaggeration() {
    scene.verticalExaggeration = Number(viewModel.exaggeration);
    updateGlobeMaterial(); // Update the material when exaggeration changes
  }

  // Create the vertical exaggeration slider HTML
  const toolbarContainer = document.createElement('div');
  toolbarContainer.id = 'toolbar';
  toolbarContainer.style.position = 'absolute';
  toolbarContainer.style.top = '10px';
  toolbarContainer.style.right = '10px';
  toolbarContainer.style.padding = '10px';
  toolbarContainer.style.backgroundColor = 'rgba(255, 255, 255, 0.7)';
  toolbarContainer.style.borderRadius = '5px';
  toolbarContainer.innerHTML = `
    <div>
      <div>Vertical Exaggeration: <span data-bind="text: exaggeration"></span>x</div>
      <input type="range" min="1" max="10" step="0.1" data-bind="value: exaggeration, valueUpdate: 'input'">
    </div>
  `;
  document.body.appendChild(toolbarContainer);

  // Setup Knockout bindings for sliders
  Cesium.knockout.track(viewModel);
  const toolbar = document.getElementById("toolbar");
  Cesium.knockout.applyBindings(viewModel, toolbar);
  for (const name in viewModel) {
    if (viewModel.hasOwnProperty(name)) {
      Cesium.knockout.getObservable(viewModel, name).subscribe(updateExaggeration);
    }
  }

  // Apply the initial globe material
  updateGlobeMaterial();

  // ===== Debug Panel Setup =====
  // Create a debug panel to show orientation information
  const debugPanel = document.createElement('div');
  debugPanel.id = 'debugPanel';
  debugPanel.style.position = 'absolute';
  debugPanel.style.bottom = '10px';
  debugPanel.style.left = '10px';
  debugPanel.style.padding = '10px';
  debugPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
  debugPanel.style.color = 'white';
  debugPanel.style.borderRadius = '5px';
  debugPanel.style.fontFamily = 'monospace';
  debugPanel.style.fontSize = '12px';
  debugPanel.style.maxWidth = '300px';
  debugPanel.style.maxHeight = '200px';
  debugPanel.style.overflow = 'auto';
  debugPanel.innerHTML = `
    <h3>ROV Orientation Info</h3>
    <div id="orientationInfo">
      <div>Heading: <span id="headingValue">N/A</span>°</div>
      <div>Quaternion: <span id="quaternionValue">N/A</span></div>
    </div>
  `;
  document.body.appendChild(debugPanel);

  // Load and display the CZML
  try {
    // Try to load the latest CZML file with today's date
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    console.log(`Looking for CZML file with date: ${today}`);
    
    // Define potential file paths to try
    const filePaths = [
      `./NA156_H2021_${today}.czml`,
      "./NA156_H2021_manual.czml",
      // Add any other potential file names here
    ];
    
    console.log("Attempting to load CZML from the following paths:", filePaths);
    
    let czmlDataSource = null;
    let loadSuccess = false;
    
    // Try each file path until one works
    for (const filePath of filePaths) {
      if (loadSuccess) break;
      
      try {
        console.log(`Trying to load: ${filePath}`);
        const czmlResource = new Cesium.Resource({
          url: filePath,
          proxy: new Cesium.DefaultProxy('/proxy/')
        });
        
        czmlDataSource = await Cesium.CzmlDataSource.load(czmlResource);
        console.log(`Successfully loaded: ${filePath}`);
        loadSuccess = true;
      } catch (error) {
        console.log(`Failed to load: ${filePath}`, error);
      }
    }
    
    // If no local files worked, try from Ion
    if (!loadSuccess) {
      console.log("Local CZML not found, using Ion asset instead...");
      const ionResource = await Cesium.IonResource.fromAssetId(3167337);
      czmlDataSource = await Cesium.CzmlDataSource.load(ionResource);
      console.log("Successfully loaded CZML from Ion");
      loadSuccess = true;
    }
    
    if (!loadSuccess || !czmlDataSource) {
      throw new Error("Failed to load any CZML source");
    }

    await viewer.dataSources.add(czmlDataSource);
    console.log("CZML added to viewer");

    // Get the Hercules entity
    const herculesEntity = czmlDataSource.entities.getById("Hercules");

    if (herculesEntity) {
      console.log("Found Hercules entity in CZML");
      // Use the clock settings from the CZML
      viewer.clock.multiplier = 10;

      // Add listener to display orientation changes
      viewer.clock.onTick.addEventListener(function() {
        if (herculesEntity.orientation) {
          try {
            // Get current orientation
            const orientation = herculesEntity.orientation.getValue(viewer.clock.currentTime);
            if (orientation) {
              // Convert quaternion to heading
              const qx = orientation.x;
              const qy = orientation.y;
              const qz = orientation.z;
              const qw = orientation.w;
              
              // Calculate heading (approximate for simple quaternions)
              let heading = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
              heading = heading * (180 / Math.PI); // Convert to degrees
              if (heading < 0) heading += 360; // Normalize to 0-360
              
              // Update debug panel
              document.getElementById('headingValue').textContent = heading.toFixed(1);
              document.getElementById('quaternionValue').textContent = 
                `[${qx.toFixed(3)}, ${qy.toFixed(3)}, ${qz.toFixed(3)}, ${qw.toFixed(3)}]`;
            }
          } catch (error) {
            console.error("Error updating orientation debug:", error);
          }
        }
      });

      // Load the ROV model
      try {
        console.log("Loading ROV model from Ion...");
        const modelResource = await Cesium.IonResource.fromAssetId(2961836);

        // Create model with manual orientation adjustment
        herculesEntity.model = new Cesium.ModelGraphics({
          uri: modelResource,
          scale: 0.04, // Scale to represent approximately 4 meters length
          minimumPixelSize: 64,
          maximumScale: 20,
          runAnimations: true,
          // No need for additional transformations - using CZML orientation
        });

        // Track the ROV with the camera
        viewer.trackedEntity = herculesEntity;

        // Add a better camera position relative to the ROV
        viewer.trackedEntityChanged.addEventListener(function() {
          viewer.zoomTo(herculesEntity, new Cesium.HeadingPitchRange(
            0, // Use the entity's orientation for heading
            -Math.PI/6, // Look down slightly
            15 // 15 meters range for better visibility
          ));
        });

        // Adjust camera settings for better viewing
        viewer.scene.screenSpaceCameraController.minimumZoomDistance = 2;
        viewer.scene.screenSpaceCameraController.maximumZoomDistance = 100;
      } catch (modelError) {
        console.error("Failed to load ROV model:", modelError);
      }
    } else {
      console.error("Hercules entity not found in CZML data");
    }
  } catch (err) {
    console.error("Error loading data:", err);
  }

  // Add UI controls for toggling visualization features
  if (typeof Sandcastle !== 'undefined') {
    Sandcastle.addToggleButton("Lighting enabled", true, function (checked) {
      globe.enableLighting = checked;
    });

    Sandcastle.addToggleButton("Fog enabled", true, (checked) => {
      scene.fog.enabled = checked;
      globe.showGroundAtmosphere = checked;
    });

    Sandcastle.addToggleButton(
      "Color ramp enabled",
      showElevationColorRamp,
      function (checked) {
        showElevationColorRamp = checked;
        updateGlobeMaterial();
      },
    );

    Sandcastle.addToggleButton(
      "Contour lines enabled",
      showContourLines,
      function (checked) {
        showContourLines = checked;
        updateGlobeMaterial();
      },
    );

    Sandcastle.addToggleButton(
      "Invert contour line color",
      invertContourLines,
      function (checked) {
        invertContourLines = checked;
        updateGlobeMaterial();
      },
    );
  } else {
    // Create simple buttons if Sandcastle isn't available
    const createToggleButton = (label, initialState, callback) => {
      const button = document.createElement('button');
      button.textContent = `${label}: ${initialState ? 'ON' : 'OFF'}`;
      button.style.margin = '5px';
      button.style.padding = '5px 10px';

      let state = initialState;
      button.onclick = () => {
        state = !state;
        button.textContent = `${label}: ${state ? 'ON' : 'OFF'}`;
        callback(state);
      };

      toolbarContainer.appendChild(button);
    };

    // Add visualization toggle buttons
    createToggleButton("Lighting", true, (checked) => {
      globe.enableLighting = checked;
    });

    createToggleButton("Fog", true, (checked) => {
      scene.fog.enabled = checked;
      globe.showGroundAtmosphere = checked;
    });

    createToggleButton("Color ramp", showElevationColorRamp, (checked) => {
      showElevationColorRamp = checked;
      updateGlobeMaterial();
    });

    createToggleButton("Contour lines", showContourLines, (checked) => {
      showContourLines = checked;
      updateGlobeMaterial();
    });

    createToggleButton("Invert contours", invertContourLines, (checked) => {
      invertContourLines = checked;
      updateGlobeMaterial();
    });
  }
})();